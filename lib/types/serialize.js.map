{"version":3,"file":"serialize.js","sourceRoot":"","sources":["../../src/types/serialize.ts"],"names":[],"mappings":"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","sourcesContent":["import \"reflect-metadata\";\r\n\r\nconst apiMap = \"api:map:\";\r\nconst apiMapSerializable = `${apiMap}serializable`;\r\nconst designType = \"design:type\";\r\nconst designParamTypes = \"design:paramtypes\";\r\n\r\n// Enums\r\nenum Type {\r\n  Array = \"array\",\r\n  Boolean = \"boolean\",\r\n  Date = \"date\",\r\n  Number = \"number\",\r\n  Object = \"object\",\r\n  String = \"string\",\r\n}\r\n\r\n// Types\r\ntype Args =\r\n  | string\r\n  | {\r\n      name?: string;\r\n      type?: Function;\r\n      onSerialize?: Function;\r\n      onDeserialize?: Function;\r\n      postDeserialize?: Function;\r\n      isDictionary?: boolean;\r\n    }\r\n  | {\r\n      name?: string;\r\n      predicate?: Function;\r\n      onSerialize?: Function;\r\n      onDeserialize?: Function;\r\n      postDeserialize?: Function;\r\n      isDictionary?: boolean;\r\n    }\r\n  | {\r\n      names: Array<string>;\r\n      type?: Function;\r\n      onSerialize?: Function;\r\n      onDeserialize?: Function;\r\n      postDeserialize?: Function;\r\n    }\r\n  | {\r\n      names: Array<string>;\r\n      predicate?: Function;\r\n      onSerialize?: Function;\r\n      onDeserialize?: Function;\r\n      postDeserialize?: Function;\r\n    };\r\n\r\ntype Metadata =\r\n  | {\r\n      name: string;\r\n      type: Function | undefined;\r\n      onSerialize: Function | undefined;\r\n      onDeserialize: Function | undefined;\r\n      postDeserialize: Function | undefined;\r\n      isDictionary: boolean;\r\n    }\r\n  | {\r\n      name: string;\r\n      predicate: Function;\r\n      onSerialize: Function | undefined;\r\n      onDeserialize: Function | undefined;\r\n      postDeserialize: Function | undefined;\r\n      isDictionary: boolean;\r\n    }\r\n  | {\r\n      names: Array<string>;\r\n      type: Function | undefined;\r\n      onSerialize: Function | undefined;\r\n      onDeserialize: Function | undefined;\r\n      postDeserialize: Function | undefined;\r\n    }\r\n  | {\r\n      names: Array<string>;\r\n      predicate: Function;\r\n      onSerialize: Function | undefined;\r\n      onDeserialize: Function | undefined;\r\n      postDeserialize: Function | undefined;\r\n    };\r\n\r\n/**\r\n * Function to get all base class names recursively\r\n *\r\n * @param {Object} target The target class from which the parent classes are extracted\r\n * @returns {Array<string>} All the base class names\r\n */\r\nfunction getBaseClassNames(target: Object): Array<string> {\r\n  const names: Array<string> = [];\r\n  const baseClass: any = Reflect.getPrototypeOf(target);\r\n\r\n  if (!baseClass || !baseClass[\"name\"]) {\r\n    return names;\r\n  }\r\n\r\n  names.push(baseClass[\"name\"]);\r\n  return [...names, ...getBaseClassNames(baseClass)];\r\n}\r\n\r\n/**\r\n * Function to find the name of function properties\r\n *\r\n * @param {object} ctor The constructor from which the properties are extracted\r\n * @returns {Array<string>} All the property names\r\n */\r\nfunction getPropertyNames(ctor: object): Map<number, string> {\r\n  // Remove all kind of comments\r\n  const ctorWithoutComments = ctor\r\n    .toString()\r\n    .replace(/(\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*$)/gm, \"\");\r\n  const ctorOnSingleLine = ctorWithoutComments.replace(/[\\r\\t\\n\\v\\f]/g, \"\");\r\n  const ctorWithoutSuccessiveWhiteSpaces = ctorOnSingleLine.replace(\r\n    /( +)/g,\r\n    \" \"\r\n  );\r\n\r\n  // Parse function body\r\n  const constructorParamPattern = /(?:.*(?:constructor|function).*?(?=\\())(?:\\()(.+?(?=\\)))/m;\r\n  const propertyPattern = /(?:this\\.)([^\\n\\r\\t\\f\\v;]+)([\\s;])/gm;\r\n  const propertyNames = new Map<number, string>();\r\n  const paramsExecArray = constructorParamPattern.exec(\r\n    ctorWithoutSuccessiveWhiteSpaces\r\n  );\r\n\r\n  if (!paramsExecArray || !paramsExecArray.length) {\r\n    return propertyNames;\r\n  }\r\n\r\n  const params = paramsExecArray[1].replace(/ /g, \"\").split(\",\");\r\n  let match: any;\r\n\r\n  // Get params\r\n  while ((match = propertyPattern.exec(ctorWithoutSuccessiveWhiteSpaces))) {\r\n    const matchResult = match[1].replace(/ /g, \"\").split(\"=\");\r\n    const index = params.findIndex((param) => param === matchResult[1]);\r\n\r\n    if (index > -1) {\r\n      propertyNames.set(index, matchResult[0]);\r\n    }\r\n  }\r\n\r\n  return propertyNames;\r\n}\r\n\r\n/**\r\n * Decorator to take the property in account during the serialize and deserialize function\r\n * @param {Args} args Arguments to describe the property\r\n */\r\n\r\nexport function JsonProperty(args?: any): Function {\r\n  return (\r\n    target: Object | Function | any,\r\n    key: string,\r\n    index: number\r\n  ): void => {\r\n    if (key === undefined && target[\"prototype\"]) {\r\n      const type: Function = Reflect.getMetadata(designParamTypes, target)[\r\n        index\r\n      ];\r\n      const keys: any = getPropertyNames(target[\"prototype\"].constructor);\r\n      key = keys.get(index);\r\n      target = target[\"prototype\"];\r\n      Reflect.defineMetadata(designType, type, target, key);\r\n    }\r\n\r\n    let map: { [id: string]: Metadata } = {};\r\n    const targetName = target.constructor.name;\r\n    const apiMapTargetName = `${apiMap}${targetName}`;\r\n\r\n    if (Reflect.hasMetadata(apiMapTargetName, target)) {\r\n      map = Reflect.getMetadata(apiMapTargetName, target);\r\n    }\r\n\r\n    map[key] = getJsonPropertyValue(key, args);\r\n    Reflect.defineMetadata(apiMapTargetName, map, target);\r\n  };\r\n}\r\n\r\n/**\r\n * Decorator to make a class Serializable\r\n *\r\n * BREAKING CHANGE: Since version 2.0.0 the parameter `baseClassName` is not needed anymore\r\n */\r\nexport function Serializable(): Function {\r\n  return (target: Object) => {\r\n    const baseClassNames = getBaseClassNames(target);\r\n    Reflect.defineMetadata(apiMapSerializable, baseClassNames, target);\r\n  };\r\n}\r\n\r\n/**\r\n * Function to retrieve and merge all base class properties\r\n *\r\n * @param baseClassNames The base classe names of the instance provided\r\n * @param {any} instance The instance target from which the parents metadata are extracted\r\n * @returns {{ [id: string]: Metadata }} All base class metadata properties\r\n */\r\nfunction getBaseClassMaps(\r\n  baseClassNames: Array<string>,\r\n  instance: any\r\n): { [id: string]: Metadata } {\r\n  let baseClassMaps: { [id: string]: Metadata } = {};\r\n\r\n  baseClassNames.forEach((baseClassName) => {\r\n    baseClassMaps = {\r\n      ...baseClassMaps,\r\n      ...Reflect.getMetadata(`${apiMap}${baseClassName}`, instance),\r\n    };\r\n  });\r\n\r\n  return baseClassMaps;\r\n}\r\n\r\n/**\r\n * Function to deserialize json into a class\r\n *\r\n * @param {object} json The json to deserialize\r\n * @param {new (...params: Array<any>) => T} type The class in which we want to deserialize\r\n * @returns {T} The instance of the specified type containing all deserialized properties\r\n */\r\nexport function deserialize<T>(\r\n  json: any,\r\n  type: new (...params: Array<any>) => T\r\n): T {\r\n  if ([null, undefined].includes(json)) {\r\n    return json as never;\r\n  }\r\n\r\n  if (type === undefined) {\r\n    return castSimpleData(typeof json, json);\r\n  }\r\n\r\n  const instance: any = new type();\r\n  const instanceName = instance.constructor.name;\r\n  const baseClassNames: Array<string> = Reflect.getMetadata(\r\n    apiMapSerializable,\r\n    type\r\n  );\r\n  const apiMapInstanceName = `${apiMap}${instanceName}`;\r\n  const hasMap = Reflect.hasMetadata(apiMapInstanceName, instance);\r\n  let instanceMap: { [id: string]: Metadata } = {};\r\n\r\n  if (!hasMap && (!baseClassNames || !baseClassNames.length)) {\r\n    return instance;\r\n  }\r\n\r\n  instanceMap = Reflect.getMetadata(apiMapInstanceName, instance);\r\n\r\n  if (baseClassNames && baseClassNames.length) {\r\n    instanceMap = {\r\n      ...instanceMap,\r\n      ...getBaseClassMaps(baseClassNames, instance),\r\n    };\r\n  }\r\n\r\n  Object.keys(instanceMap).forEach((key) => {\r\n    const property = convertDataToProperty(\r\n      instance,\r\n      key,\r\n      instanceMap[key],\r\n      json\r\n    );\r\n\r\n    if (property !== undefined) {\r\n      instance[key] = property;\r\n    }\r\n  });\r\n\r\n  return instance;\r\n}\r\n\r\n/**\r\n * Function to serialize a class into json\r\n *\r\n * @param {any} instance Instance of the object to deserialize\r\n * @param {boolean} removeUndefined Indicates if you want to keep or remove undefined values\r\n * @returns {any} The json object\r\n */\r\nexport function serialize(instance: any, removeUndefined: boolean = true): any {\r\n  if ([undefined, null].includes(instance) || typeof instance !== Type.Object) {\r\n    return instance;\r\n  }\r\n\r\n  const instanceName = instance.constructor.name;\r\n  const apiMapInstanceName = `${apiMap}${instanceName}`;\r\n  const baseClassNames: Array<string> = Reflect.getMetadata(\r\n    apiMapSerializable,\r\n    instance.constructor\r\n  );\r\n  const hasBaseClasses = baseClassNames && baseClassNames.length;\r\n\r\n  const hasMap = Reflect.hasMetadata(apiMapInstanceName, instance);\r\n  let instanceMap: { [id: string]: any } = {};\r\n\r\n  if (!hasMap && !hasBaseClasses) {\r\n    return instance;\r\n  }\r\n\r\n  instanceMap = Reflect.getMetadata(apiMapInstanceName, instance);\r\n\r\n  if (hasBaseClasses) {\r\n    instanceMap = {\r\n      ...instanceMap,\r\n      ...getBaseClassMaps(baseClassNames, instance),\r\n    };\r\n  }\r\n\r\n  const json: any = {};\r\n  const instanceKeys = Object.keys(instance);\r\n\r\n  Object.keys(instanceMap).forEach((key) => {\r\n    const onSerialize: Function = instanceMap[key][\"onSerialize\"];\r\n\r\n    if (instanceKeys.includes(key)) {\r\n      let data = convertPropertyToData(\r\n        instance,\r\n        key,\r\n        instanceMap[key],\r\n        removeUndefined\r\n      );\r\n\r\n      if (onSerialize) {\r\n        data = onSerialize(data, instance);\r\n      }\r\n\r\n      if (instanceMap[key][\"names\"]) {\r\n        instanceMap[key][\"names\"].forEach((name: string) => {\r\n          if (\r\n            !removeUndefined ||\r\n            (removeUndefined && data[name] !== undefined)\r\n          ) {\r\n            json[name] = data[name];\r\n          }\r\n        });\r\n      } else {\r\n        if (!removeUndefined || (removeUndefined && data !== undefined)) {\r\n          json[instanceMap[key][\"name\"]] = data;\r\n        }\r\n      }\r\n    }\r\n  });\r\n\r\n  return json;\r\n}\r\n\r\n/**\r\n * Function to convert class property to json data\r\n *\r\n * @param {Function} instance The instance containing the property to convert\r\n * @param {string} key The name of the property to convert\r\n * @param {Metadata} metadata The metadata of the property to convert\r\n * @param {boolean} removeUndefined Indicates if you want to keep or remove undefined value\r\n * @returns {any} The converted property\r\n */\r\nfunction convertPropertyToData(\r\n  instance: any,\r\n  key: string,\r\n  metadata: any,\r\n  removeUndefined: boolean\r\n): any {\r\n  const property: any = instance[key];\r\n  const type: any = Reflect.getMetadata(designType, instance, key);\r\n  const isArray = type.name.toLocaleLowerCase() === Type.Array;\r\n  const predicate: Function = metadata[\"predicate\"];\r\n  const propertyType: any = metadata[\"type\"] || type;\r\n  const isSerializableProperty = isSerializable(propertyType);\r\n\r\n  if (property && (isSerializableProperty || predicate)) {\r\n    if (isArray) {\r\n      const array: any[] = [];\r\n      property.forEach((d: any) => {\r\n        array.push(serialize(d, removeUndefined));\r\n      });\r\n\r\n      return array;\r\n    }\r\n\r\n    if (metadata[\"isDictionary\"]) {\r\n      const obj: any = {};\r\n      Object.keys(property).forEach((k) => {\r\n        obj[k] = serialize(property[k], removeUndefined);\r\n      });\r\n\r\n      return obj;\r\n    }\r\n\r\n    return serialize(property, removeUndefined);\r\n  }\r\n\r\n  if (propertyType.name.toLocaleLowerCase() === Type.Date) {\r\n    return property ? property.toISOString() : property;\r\n  }\r\n\r\n  return property;\r\n}\r\n\r\n/**\r\n * Function to convert json data to the class property\r\n * @param {Function} instance The instance containing the property to convert\r\n * @param {string} key The name of the property to convert\r\n * @param {Metadata} metadata The metadata of the property to convert\r\n * @param {any} json Json containing the values\r\n */\r\nfunction convertDataToProperty(\r\n  instance: Function,\r\n  key: string,\r\n  metadata: any,\r\n  json: any\r\n) {\r\n  let data: any;\r\n\r\n  if ([null, undefined].includes(json)) {\r\n    return json;\r\n  }\r\n\r\n  if (metadata[\"names\"]) {\r\n    const object: any = {};\r\n    metadata[\"names\"].forEach((name: string) => (object[name] = json[name]));\r\n    data = object;\r\n  } else {\r\n    data = json[metadata[\"name\"]];\r\n  }\r\n\r\n  if ([null, undefined].includes(data)) {\r\n    return data;\r\n  }\r\n\r\n  const type: any = Reflect.getMetadata(designType, instance, key);\r\n  const isArray = type.name.toLowerCase() === Type.Array;\r\n  const isDictionary = metadata[\"isDictionary\"];\r\n  const predicate: Function = metadata[\"predicate\"];\r\n  const onDeserialize: Function = metadata[\"onDeserialize\"];\r\n  const postDeserialize: Function = metadata[\"postDeserialize\"];\r\n  let propertyType: any = metadata[\"type\"] || type;\r\n  const isSerializableProperty = isSerializable(propertyType);\r\n  let result: any;\r\n\r\n  if (onDeserialize) {\r\n    data = onDeserialize(data, instance);\r\n  }\r\n\r\n  if (!isSerializableProperty && !predicate) {\r\n    result = castSimpleData(propertyType.name, data);\r\n  } else if (isArray) {\r\n    const array: any[] = [];\r\n\r\n    if (!Array.isArray(data)) {\r\n      console.error(`${data} is not an array.`);\r\n      result = undefined;\r\n    } else {\r\n      data.forEach((d: any) => {\r\n        if (predicate) {\r\n          propertyType = predicate(d);\r\n        }\r\n        array.push(deserialize(d, propertyType));\r\n      });\r\n      result = array;\r\n    }\r\n  } else if (isDictionary) {\r\n    const obj: any = {};\r\n\r\n    if (typeof data !== Type.Object) {\r\n      console.error(`${data} is not an object.`);\r\n      result = undefined;\r\n    } else {\r\n      Object.keys(data).forEach((k) => {\r\n        if (predicate) {\r\n          propertyType = predicate(data[k]);\r\n        }\r\n        obj[k] = deserialize(data[k], propertyType);\r\n      });\r\n      result = obj;\r\n    }\r\n  } else {\r\n    propertyType = predicate ? predicate(data) : propertyType;\r\n    result = deserialize(data, propertyType);\r\n  }\r\n\r\n  if (postDeserialize) {\r\n    result = postDeserialize(result, instance);\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Function to test if a class is serializable\r\n *\r\n * @param {any} type The type to test\r\n * @returns {boolean} If the type is serializable or not\r\n */\r\nfunction isSerializable(type: any): boolean {\r\n  return Reflect.hasOwnMetadata(apiMapSerializable, type);\r\n}\r\n\r\n/**\r\n * Function to transform the JsonProperty value into Metadata\r\n *\r\n * @param {string} key The property name\r\n * @param {Args} args Arguments to describe the property\r\n * @returns {Metadata} The metadata object\r\n */\r\nfunction getJsonPropertyValue(key: string, args: any): Metadata {\r\n  if (!args) {\r\n    return {\r\n      name: key.toString(),\r\n      type: undefined,\r\n      onDeserialize: undefined,\r\n      onSerialize: undefined,\r\n      postDeserialize: undefined,\r\n      isDictionary: false,\r\n    };\r\n  }\r\n\r\n  let metadata: any;\r\n  if (typeof args === Type.String) {\r\n    metadata = { name: args };\r\n  } else if (args[\"name\"]) {\r\n    metadata = { name: args[\"name\"] };\r\n  } else if (args[\"names\"] && args[\"names\"].length) {\r\n    metadata = { names: args[\"names\"] };\r\n  } else {\r\n    metadata = { name: key.toString() };\r\n  }\r\n\r\n  return args[\"predicate\"]\r\n    ? {\r\n        ...metadata,\r\n        predicate: args[\"predicate\"],\r\n        onDeserialize: args[\"onDeserialize\"],\r\n        onSerialize: args[\"onSerialize\"],\r\n        postDeserialize: args[\"postDeserialize\"],\r\n        isDictionary: !!args[\"isDictionary\"],\r\n      }\r\n    : {\r\n        ...metadata,\r\n        type: args[\"type\"],\r\n        onDeserialize: args[\"onDeserialize\"],\r\n        onSerialize: args[\"onSerialize\"],\r\n        postDeserialize: args[\"postDeserialize\"],\r\n        isDictionary: !!args[\"isDictionary\"],\r\n      };\r\n}\r\n\r\n/**\r\n * Function to cast simple type data into the real class property type\r\n *\r\n * @param {string} type The type to cast data into\r\n * @param {any} data The data to cast\r\n * @returns {any} The casted data\r\n */\r\nfunction castSimpleData(type: string, data: any): any {\r\n  type = type.toLowerCase();\r\n\r\n  if ((typeof data).toLowerCase() === type) {\r\n    return data;\r\n  }\r\n\r\n  switch (type) {\r\n    case Type.String:\r\n      return data ? data.toString() : data;\r\n    case Type.Number:\r\n      const number: number = +data;\r\n      if (isNaN(number)) {\r\n        console.error(\r\n          `${data}: Type ${typeof data} is not assignable to type ${type}.`\r\n        );\r\n        return undefined;\r\n      }\r\n      return number;\r\n    case Type.Boolean:\r\n      console.error(\r\n        `${data}: Type ${typeof data} is not assignable to type ${type}.`\r\n      );\r\n      return undefined;\r\n    case Type.Date:\r\n      if (isNaN(Date.parse(data))) {\r\n        console.error(\r\n          `${data}: Type ${typeof data} is not assignable to type ${type}.`\r\n        );\r\n        return undefined;\r\n      }\r\n      return new Date(data);\r\n    default:\r\n      return data;\r\n  }\r\n}\r\n"]}